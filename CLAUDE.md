# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Common Development Commands

### Running Tools

```bash
# List all available tools interactively
tools

# Run a specific tool
tools <tool-name> [args]

# View a tool's README documentation
tools <tool-name> --readme

# Examples:
tools git-last-commits-diff . --commits 3 --clipboard
tools collect-files-for-ai ./my-repo -c 5
tools files-to-prompt src/ --cxml > prompt.xml
tools watch "src/**/*.ts" -v
tools npm-package-diff react 18.0.0 18.2.0
tools ask --readme  # View ask tool documentation
```

### Installation & Setup

```bash
# Initial setup (requires Bun)
bun install && ./install.sh
source ~/.zshrc  # or ~/.bashrc

# The install script adds GenesisTools to PATH by modifying shell config files
```

## Architecture Overview

GenesisTools is a TypeScript-based CLI toolkit that runs on Bun. The architecture follows a plugin pattern where each tool is self-contained:

### Core Structure

-   **Entry Point**: The `tools` executable is a TypeScript file with a shebang that:
  -   Without arguments: Shows an interactive tool selector using @inquirer/prompts
  -   With arguments: Executes the specified tool by running `bun run` on the appropriate file
-   **Tool Discovery**: Tools are discovered by checking `/src/` for:
  -   Directories containing `index.ts` or `index.tsx` (tool name = directory name)
  -   Standalone `.ts` or `.tsx` files (tool name = filename without extension)
-   **Execution Model**: Each tool runs in its own process via `bun run`, inheriting stdio for seamless interaction

### Key Components

-   **Logger** (`src/logger.ts`): Centralized logging using pino, outputs to `/logs/` directory organized by date
-   **MCP Integration**: Several tools implement Model Context Protocol servers for AI assistant integration
-   **No Build Step**: Bun executes TypeScript directly without compilation

### Utility Convention

When creating a new tool and writing helper functions, check if the utility is **general-purpose** (usable by other tools). If so, place it in `src/utils/` instead of inside the tool directory:

- `src/utils/format.ts` - Formatting: bytes, duration, tokens, numbers, lists
- `src/utils/table.ts` - Text table formatting
- `src/utils/string.ts` - String utilities (glob matching, ANSI stripping)
- `src/utils/storage/storage.ts` - Config & cache management
- `src/utils/async.ts` - Async helpers (concurrency, etc.)
- `src/utils/json-schema.ts` - JSON schema inference: `inferSchema()`, `formatSchema(value, "skeleton"|"typescript"|"schema")`

Tool-specific logic stays in the tool directory (e.g., `src/har-analyzer/core/`).

### Tool Patterns

Most tools follow these common patterns:

**CLI Argument Parsing**:

-   Use `commander` for parsing command-line arguments with subcommands and options
-   Define command structure with `.command()`, `.option()`, and `.action()`
-   Provide clear `--help` documentation with usage examples (auto-generated by commander)

**Interactive User Experience**:

-   Two prompt libraries available: `@inquirer/prompts` (legacy) and `@clack/prompts` (preferred for new tools)
-   See "Choosing a Prompt Library" below for when to use each
-   Common prompt types: `select`, `input`, `confirm`, `checkbox`/`multiselect`
-   Handle user cancellation gracefully
-   Provide sensible defaults and suggestions in prompts

**Output Handling**:

-   Support multiple output destinations: file, clipboard, stdout
-   Use `clipboardy` for clipboard operations
-   Use `chalk` for colored terminal output (but strip ANSI codes for non-TTY)
-   Respect `--silent` and `--verbose` flags

**Process Execution**:

-   Use `Bun.spawn()` for executing external commands
-   Handle stdout/stderr streams properly using `new Response(proc.stdout).text()`
-   Always check exit codes and provide meaningful error messages

**File Operations**:

-   Use Node.js `path` module for cross-platform path handling
-   Resolve relative paths to absolute using `resolve()`
-   Check file/directory existence before operations
-   Use Bun's native file APIs (`Bun.write()`) for better performance

## How to Write More Tools

To create a new tool for GenesisTools, follow this guide:

### 1. Tool Structure

Create either:

-   A directory under `/src/your-tool-name/` with an `index.ts` or `index.tsx` file, OR
-   A single file `/src/your-tool-name.ts`

### 2. Basic Tool Template

```typescript
import { Command } from "commander";
import { input, select } from "@inquirer/prompts";
import { ExitPromptError } from "@inquirer/core";
import chalk from "chalk";
import clipboardy from "clipboardy";
import logger from "../logger";

// Define your options interface
interface Options {
    input?: string;
    output?: string;
    verbose?: boolean;
}

const program = new Command();

program
    .name("your-tool-name")
    .description("Description of what your tool does")
    .argument("[input]", "Input file or directory")
    .option("-i, --input <path>", "Input file or directory")
    .option("-o, --output <path>", "Output destination")
    .option("-v, --verbose", "Enable verbose logging")
    .action(async (inputArg, options: Options) => {
        try {
            await main(inputArg, options);
        } catch (error) {
            if (error instanceof ExitPromptError) {
                logger.info("\nOperation cancelled by user.");
                process.exit(0);
            }
            throw error;
        }
    });

async function main(inputArg: string | undefined, options: Options) {
    // Get input - from args or interactive prompt
    let inputPath = options.input || inputArg;

    if (!inputPath) {
        inputPath = await input({
            message: "Enter input path:",
        });
    }

    // Your tool logic here
    // Example: Process the input
    const result = await processInput(inputPath);

    // Handle output
    if (options.output) {
        await Bun.write(options.output, result);
        logger.info(`✔ Output written to ${options.output}`);
    } else {
        // Interactive output selection
        const outputChoice = await select({
            message: "Where to output?",
            choices: [
                { value: "clipboard", name: "clipboard" },
                { value: "stdout", name: "stdout" },
                { value: "file", name: "file" },
            ],
        });

        switch (outputChoice) {
            case "clipboard":
                await clipboardy.write(result);
                logger.info("✔ Copied to clipboard!");
                break;
            case "stdout":
                console.log(result);
                break;
            case "file":
                // Prompt for filename...
                break;
        }
    }
}

// Your processing function
async function processInput(inputPath: string): Promise<string> {
    // Implement your tool's core logic
    return `Processed: ${inputPath}`;
}

// Run the tool
program.parse();
```

### Choosing a Prompt Library

We support two prompt libraries. Choose based on your needs:

| Use Case | Library | Why |
|----------|---------|-----|
| **New tools** (preferred) | `@clack/prompts` | Beautiful UI, built-in spinners, structured logging |
| Multi-step wizards | `@clack/prompts` | `p.intro()`, `p.outro()`, `p.spinner()` for flow |
| Need `editor` prompt | `@inquirer/prompts` | No clack equivalent for multiline editor |
| Modifying existing tool | Keep current library | Don't mix libraries in same file |

**Full guide:** See `.claude/docs/prompts-and-colors.md` for comprehensive documentation.

### Alternative Template: @clack/prompts (Preferred for New Tools)

```typescript
import { Command } from "commander";
import * as p from "@clack/prompts";
import pc from "picocolors";
import clipboardy from "clipboardy";
import logger from "../logger";

interface Options {
    input?: string;
    output?: string;
    verbose?: boolean;
}

const program = new Command();

program
    .name("your-tool-name")
    .description("Description of what your tool does")
    .argument("[input]", "Input file or directory")
    .option("-i, --input <path>", "Input file or directory")
    .option("-o, --output <path>", "Output destination")
    .option("-v, --verbose", "Enable verbose logging")
    .action(async (inputArg, options: Options) => {
        await main(inputArg, options);
    });

async function main(inputArg: string | undefined, options: Options) {
    p.intro(pc.bgCyan(pc.black(" your-tool-name ")));

    // Get input - from args or interactive prompt
    let inputPath = options.input || inputArg;

    if (!inputPath) {
        const result = await p.text({
            message: "Enter input path:",
            placeholder: "/path/to/file",
        });

        if (p.isCancel(result)) {
            p.cancel("Operation cancelled");
            process.exit(0);
        }
        inputPath = result;
    }

    // Spinner for async work
    const spinner = p.spinner();
    spinner.start("Processing...");
    const result = await processInput(inputPath);
    spinner.stop("Processing complete");

    // Handle output
    if (options.output) {
        await Bun.write(options.output, result);
        p.log.success(`Output written to ${options.output}`);
    } else {
        const outputChoice = await p.select({
            message: "Where to output?",
            options: [
                { value: "clipboard", label: "Clipboard" },
                { value: "stdout", label: "Console" },
                { value: "file", label: "File" },
            ],
        });

        if (p.isCancel(outputChoice)) {
            p.cancel("Operation cancelled");
            process.exit(0);
        }

        switch (outputChoice) {
            case "clipboard":
                await clipboardy.write(result);
                p.log.success("Copied to clipboard!");
                break;
            case "stdout":
                console.log(result);
                break;
            case "file":
                // Prompt for filename...
                break;
        }
    }

    p.outro(pc.green("Done!"));
}

async function processInput(inputPath: string): Promise<string> {
    return `Processed: ${inputPath}`;
}

program.parse();
```

### 3. Common Patterns to Follow

**Using Bun.spawn for External Commands**:

```typescript
const proc = Bun.spawn({
    cmd: ["git", "status"],
    cwd: repoDir,
    stdio: ["ignore", "pipe", "pipe"],
});

const stdout = await new Response(proc.stdout).text();
const stderr = await new Response(proc.stderr).text();
const exitCode = await proc.exited;

if (exitCode !== 0) {
    logger.error(`Command failed: ${stderr}`);
}
```

**Interactive Selection with Search**:

```typescript
import { search } from "@inquirer/prompts";

const selected = await search({
    message: "Select an item:",
    source: async (term) => {
        const filtered = items.filter((item) =>
            item.display.toLowerCase().includes((term || "").toLowerCase())
        );
        return filtered.map((item) => ({
            value: item.id,
            name: item.display,
        }));
    },
});
```

**File Watching with Chokidar**:

```typescript
import chokidar from "chokidar";

const watcher = chokidar.watch(pattern, {
    persistent: true,
    ignoreInitial: false,
});

watcher.on("change", (path) => {
    logger.info(`File changed: ${path}`);
});
```

**Progress Indicators** (with @clack/prompts - preferred):

```typescript
import * as p from "@clack/prompts";

const spinner = p.spinner();
spinner.start("Processing...");
// Do work
spinner.stop("Done!"); // or spinner.stop(pc.red("Failed!"));
```

**Progress Indicators** (with ora - legacy):

```typescript
import ora from "ora";

const spinner = ora("Processing...").start();
// Do work
spinner.succeed("Done!");
// or spinner.fail("Failed!");
```

### 4. Best Practices

1. **Always provide a help message** with clear usage examples
2. **Support both CLI args and interactive mode** for better UX
3. **Use the centralized logger** instead of console.log
4. **Handle errors gracefully** with meaningful messages
5. **Support common output options**: file, clipboard, stdout
6. **Use TypeScript interfaces** for type safety
7. **Respect TTY vs non-TTY** environments (strip colors for pipes)
8. **Add verbose/debug modes** for troubleshooting
9. **Use meaningful exit codes** (0 for success, 1+ for errors)
10. **Test with various input scenarios** including edge cases

### 5. Testing Your Tool

```bash
# Test directly
bun run src/your-tool-name/index.ts --help

# Test through the tools command
tools your-tool-name --help

# Test with different inputs
tools your-tool-name test.txt -o output.txt
echo "input" | tools your-tool-name
```

## Important Notes

-   **Runtime**: This project requires Bun as it uses Bun-specific APIs (e.g., `Bun.spawn`)
-   **Global Access**: The `install.sh` script modifies shell config to add GenesisTools to PATH
-   **No Tests**: The project currently has no test suite
-   **TypeScript Config**: Strict mode enabled, ES modules, no emit (Bun runs TS directly)
-   **Logging**: Check `/logs/` directory for debug information if tools encounter errors

## Context7 Library IDs for Documentation Lookup

When researching Microsoft/Azure APIs, use these context7 library IDs:

| Library ID | Use For | Key Topics |
|------------|---------|------------|
| `/websites/learn_microsoft_en-us_rest_api_azure_devops` | Azure DevOps REST API | Work items, revisions, updates, comments, WIQL, reporting APIs |
| `/microsoftdocs/azure-docs-cli` | Azure CLI commands | `az boards`, `az devops`, `az pipelines`, `az repos`, `az rest` |
| `/microsoftdocs/azure-devops-docs` | Azure DevOps general docs | Process templates, boards config, permissions |

**Usage with context7 MCP:**
```bash
# 1. Resolve library ID
mcp__context7-mcp__resolve-library-id with libraryName="azure devops rest api"

# 2. Query docs (use the resolved ID)
mcp__context7-mcp__get-library-docs with context7CompatibleLibraryID="/websites/learn_microsoft_en-us_rest_api_azure_devops" topic="work item revisions"
```

**When to use context7 vs local docs:**
- **Context7**: For detailed API specs, parameters, response schemas, edge cases
- **Local docs** (`src/azure-devops/docs/`): Quick reference for `az` CLI commands with examples

### Local Azure DevOps CLI Documentation

See `src/azure-devops/docs/` for comprehensive CLI reference (~15K tokens total):
- `az-boards-work-item.md` - Work item CRUD
- `az-boards-iteration.md` - Sprint/iteration management
- `az-repos-pr.md` - Pull request workflows
- `az-rest.md` - Raw REST API calls
- `work-item-history-api-reference.md` - **Revisions, updates, comments APIs** (detailed)

### Azure DevOps API Quick Reference

**Batch endpoints (reduce API calls):**
- `POST /wit/workitemsbatch` - Get up to 200 work items in one call (current state only)
- `GET /wit/reporting/workitemrevisions` - **Batch history** for multiple work items (use for sync)

**Per-item endpoints:**
- `GET /wit/workitems/{id}?$expand=all` - Single work item with all fields/relations
- `GET /wit/workitems/{id}/updates` - Field change deltas (no batch available)
- `GET /wit/workitems/{id}/revisions` - Full snapshots per revision
- `GET /wit/workitems/{id}/comments` - Comments (no cross-item batch)
