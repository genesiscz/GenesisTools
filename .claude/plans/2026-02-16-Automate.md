# Automation Framework Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Build a preset-based automation framework (`tools automate`) that chains existing GenesisTools commands as sequential steps, with variable interpolation, conditional branching, and built-in actions.

**Architecture:** JSON presets define workflows as a flat array of steps. An engine reads a preset, validates it with Zod, resolves `{{ }}` expressions against a context object (`vars`, `steps`, `env`), executes steps via `Bun.spawn` (for `tools` commands) or built-in handlers (for `if`, `log`, `prompt`, `shell`, `set`), collects outputs per step, and displays progress via `@clack/prompts` spinners. Storage uses the existing `Storage` class at `~/.genesis-tools/automate/`.

**Tech Stack:** TypeScript, Bun, Commander.js, @clack/prompts, picocolors, Zod

---

## File Map

```
src/automate/
  index.ts                  # Commander setup, program entry point
  commands/
    run.ts                  # `tools automate run <preset>` command
    list.ts                 # `tools automate list` command
    show.ts                 # `tools automate show <preset>` command
    create.ts               # `tools automate create` interactive wizard
  lib/
    types.ts                # TypeScript interfaces for preset JSON
    schema.ts               # Zod schemas for validation
    engine.ts               # Main execution engine (orchestrates step execution)
    expressions.ts          # Expression evaluator for {{ }} templates
    step-runner.ts          # Individual step execution (tools commands via Bun.spawn)
    builtins.ts             # Built-in action handlers (if, log, prompt, shell, set)
    storage.ts              # Preset storage helpers (wraps Storage class)

plugins/genesis-tools/skills/automate/
  SKILL.md                  # Claude Code skill for creating/running presets
```

**No new dependencies required.** All deps already in `package.json`: `zod`, `commander`, `@clack/prompts`, `picocolors`.

---

### Task 1: Define Types

**Files:**
- Create: `src/automate/lib/types.ts`

**Step 1: Write the code**

```typescript
// src/automate/lib/types.ts

/** Variable definition in a preset */
export interface PresetVariable {
  type: "string" | "number" | "boolean";
  description: string;
  default?: string | number | boolean;
  required?: boolean;
}

/** Error handling strategy */
export type OnError = "stop" | "continue" | "skip";

/** Trigger type -- manual only for v1, extensible later */
export interface PresetTrigger {
  type: "manual";
}

/** A single step in the preset */
export interface PresetStep {
  /** Unique identifier for the step (alphanumeric, hyphens, underscores) */
  id: string;
  /** Human-readable step name shown in progress output */
  name: string;
  /** "tools <cmd>" subcommand (e.g. "github search") OR built-in: "if" | "log" | "prompt" | "shell" | "set" */
  action: string;
  /** Parameters passed to the action. Keys starting with -- become flags; others are positional args. Values can contain {{ expressions }}. */
  params?: Record<string, string | number | boolean | string[]>;
  /** Variable name to store stdout/result in ctx.steps[id] */
  output?: string;
  /** What to do on failure. Default: "stop" */
  onError?: OnError;
  /** If true, subprocess inherits stdin for interactive prompts */
  interactive?: boolean;
  /** For "if" action: expression string returning boolean (e.g. "{{ steps.x.output.count > 0 }}") */
  condition?: string;
  /** For "if" action: step ID to jump to when condition is truthy */
  then?: string;
  /** For "if" action: step ID to jump to when condition is falsy */
  else?: string;
}

/** The full preset document (JSON schema) */
export interface Preset {
  /** Schema identifier for format versioning */
  $schema: string;
  /** Preset display name */
  name: string;
  /** Optional description of what this preset does */
  description?: string;
  /** Trigger configuration (manual only in v1) */
  trigger: PresetTrigger;
  /** Variable definitions with types, descriptions, and defaults */
  vars?: Record<string, PresetVariable>;
  /** Ordered list of steps to execute */
  steps: PresetStep[];
}

/** Runtime context passed through execution */
export interface ExecutionContext {
  /** User-defined variables (from preset defaults + CLI overrides + prompts) */
  vars: Record<string, string | number | boolean>;
  /** Results from previously executed steps, keyed by step ID */
  steps: Record<string, StepResult>;
  /** Process environment variables */
  env: Record<string, string>;
}

/** Result of a single step execution */
export interface StepResult {
  status: "success" | "error" | "skipped";
  /** Parsed JSON if possible, raw string otherwise */
  output: unknown;
  exitCode?: number;
  /** Duration in milliseconds */
  duration: number;
  error?: string;
}

/** Run options from CLI flags */
export interface RunOptions {
  dryRun?: boolean;
  /** ["key=value", ...] from --var flags */
  vars?: string[];
  verbose?: boolean;
}

/** Metadata stored alongside presets for `list` command */
export interface PresetMeta {
  /** ISO date of last run */
  lastRun?: string;
  runCount?: number;
}
```

**Step 2: Verify**

Run: `tsgo --noEmit 2>&1 | rg "automate/lib/types"`
Expected: No errors (or no output matching that path).

**Step 3: Commit**

```bash
git add src/automate/lib/types.ts
git commit -m "feat(automate): define TypeScript types for preset format"
```

---

### Task 2: Zod Validation Schema

**Files:**
- Create: `src/automate/lib/schema.ts`

**Step 1: Write the code**

```typescript
// src/automate/lib/schema.ts

import { z } from "zod";

export const presetVariableSchema = z.object({
  type: z.enum(["string", "number", "boolean"]),
  description: z.string(),
  default: z.union([z.string(), z.number(), z.boolean()]).optional(),
  required: z.boolean().optional(),
});

export const presetStepSchema = z.object({
  id: z.string().regex(/^[a-zA-Z0-9_-]+$/, "Step ID must be alphanumeric with hyphens/underscores"),
  name: z.string(),
  action: z.string(),
  params: z.record(z.union([z.string(), z.number(), z.boolean(), z.array(z.string())])).optional(),
  output: z.string().optional(),
  onError: z.enum(["stop", "continue", "skip"]).optional(),
  interactive: z.boolean().optional(),
  condition: z.string().optional(),
  then: z.string().optional(),
  else: z.string().optional(),
});

export const presetSchema = z.object({
  $schema: z.string(),
  name: z.string().min(1, "Preset name is required"),
  description: z.string().optional(),
  trigger: z.object({
    type: z.literal("manual"),
  }),
  vars: z.record(presetVariableSchema).optional(),
  steps: z.array(presetStepSchema).min(1, "At least one step is required"),
});

/** Inferred TypeScript type from the Zod schema */
export type ValidatedPreset = z.infer<typeof presetSchema>;

/** Validate a preset and return typed result or throw with clear Zod errors */
export function validatePreset(data: unknown): ValidatedPreset {
  return presetSchema.parse(data);
}

/** Validate that step IDs are unique and conditional jump references point to existing steps */
export function validateStepGraph(steps: z.infer<typeof presetStepSchema>[]): string[] {
  const errors: string[] = [];
  const ids = new Set<string>();

  for (const step of steps) {
    if (ids.has(step.id)) {
      errors.push(`Duplicate step ID: "${step.id}"`);
    }
    ids.add(step.id);
  }

  for (const step of steps) {
    if (step.action === "if") {
      if (step.then && !ids.has(step.then)) {
        errors.push(`Step "${step.id}": "then" references unknown step "${step.then}"`);
      }
      if (step.else && !ids.has(step.else)) {
        errors.push(`Step "${step.id}": "else" references unknown step "${step.else}"`);
      }
    }
  }

  return errors;
}
```

**Step 2: Verify**

Run: `tsgo --noEmit 2>&1 | rg "automate/lib/schema"`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/automate/lib/schema.ts
git commit -m "feat(automate): add Zod validation schema for presets"
```

---

### Task 3: Expression Evaluator

**Files:**
- Create: `src/automate/lib/expressions.ts`

**Step 1: Write the code**

```typescript
// src/automate/lib/expressions.ts

import type { ExecutionContext } from "./types.ts";

const EXPR_REGEX = /\{\{\s*(.+?)\s*\}\}/g;

/**
 * Resolve all {{ expressions }} in a string.
 * If the entire string is a single expression that resolves to a non-string,
 * returns the raw value (boolean, number, array, object).
 * Otherwise interpolates all expressions into a string.
 */
export function resolveExpression(template: string, ctx: ExecutionContext): unknown {
  // Fast path: entire string is a single expression
  const fullMatch = template.match(/^\{\{\s*(.+?)\s*\}\}$/);
  if (fullMatch) {
    return evaluateExpression(fullMatch[1], ctx);
  }

  // Multi-expression interpolation: resolve all {{ }} blocks within the string
  return template.replace(EXPR_REGEX, (_match, expr: string) => {
    const result = evaluateExpression(expr.trim(), ctx);
    return String(result ?? "");
  });
}

/**
 * Evaluate a single expression.
 * Examples:
 *   "vars.startDate"                -> ctx.vars.startDate
 *   "steps.search.output.count"     -> ctx.steps.search.output.count
 *   "env.HOME"                      -> ctx.env.HOME
 *   "steps.search.output.count > 0" -> boolean expression via Function()
 */
function evaluateExpression(expr: string, ctx: ExecutionContext): unknown {
  // Fast path: simple dot-property access (vars.x, steps.id.output.field, env.VAR)
  const isSimplePath = /^(vars|steps|env)(\.[a-zA-Z0-9_]+)+$/.test(expr);
  if (isSimplePath) {
    return resolvePropertyPath(expr, ctx);
  }

  // Complex expression: use Function constructor with sandboxed context
  // Safe for local CLI tool where user writes their own presets
  try {
    const fn = new Function("vars", "steps", "env", `return (${expr});`);
    return fn(ctx.vars, ctx.steps, ctx.env);
  } catch (error) {
    throw new Error(
      `Expression evaluation failed: "{{ ${expr} }}" - ${error instanceof Error ? error.message : String(error)}`,
    );
  }
}

/**
 * Resolve a dot-separated property path against the context.
 * "steps.search.output.ids" -> ctx.steps.search.output.ids
 */
function resolvePropertyPath(path: string, ctx: ExecutionContext): unknown {
  const parts = path.split(".");
  let current: unknown = ctx;

  for (const part of parts) {
    if (current === null || current === undefined) return undefined;
    if (typeof current === "object") {
      current = (current as Record<string, unknown>)[part];
    } else {
      return undefined;
    }
  }

  return current;
}

/**
 * Resolve all expressions in a params object.
 * Returns a new object with all string values resolved.
 * Non-string values (numbers, booleans) pass through unchanged.
 * Arrays have each string element resolved.
 */
export function resolveParams(
  params: Record<string, string | number | boolean | string[]>,
  ctx: ExecutionContext,
): Record<string, unknown> {
  const resolved: Record<string, unknown> = {};

  for (const [key, value] of Object.entries(params)) {
    if (typeof value === "string") {
      resolved[key] = resolveExpression(value, ctx);
    } else if (Array.isArray(value)) {
      resolved[key] = value.map((v) =>
        typeof v === "string" ? resolveExpression(v, ctx) : v,
      );
    } else {
      resolved[key] = value;
    }
  }

  return resolved;
}
```

**Step 2: Verify**

Run: `tsgo --noEmit 2>&1 | rg "automate/lib/expressions"`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/automate/lib/expressions.ts
git commit -m "feat(automate): add expression evaluator for {{ }} templates"
```

---

### Task 4: Preset Storage Helpers

**Files:**
- Create: `src/automate/lib/storage.ts`

**Step 1: Write the code**

```typescript
// src/automate/lib/storage.ts

import { existsSync, mkdirSync, readdirSync } from "node:fs";
import { join, resolve } from "node:path";
import { Storage } from "@app/utils/storage/storage.ts";
import type { Preset, PresetMeta } from "./types.ts";
import { validatePreset, validateStepGraph } from "./schema.ts";

const storage = new Storage("automate");
const PRESETS_DIR = "presets";

/** Ensure storage directories exist */
export async function ensureStorage(): Promise<void> {
  await storage.ensureDirs();
  const presetsDir = join(storage.getBaseDir(), PRESETS_DIR);
  if (!existsSync(presetsDir)) {
    mkdirSync(presetsDir, { recursive: true });
  }
}

/** Get the presets directory path */
export function getPresetsDir(): string {
  return join(storage.getBaseDir(), PRESETS_DIR);
}

/**
 * Load a preset by name or file path.
 * Resolution order:
 *   1. If the argument is a path to an existing .json file, load it directly.
 *   2. Otherwise look in ~/.genesis-tools/automate/presets/<name>.json
 */
export async function loadPreset(nameOrPath: string): Promise<Preset> {
  let filePath: string;

  const resolvedPath = resolve(nameOrPath);
  if (existsSync(resolvedPath) && resolvedPath.endsWith(".json")) {
    filePath = resolvedPath;
  } else {
    const presetsDir = getPresetsDir();
    const candidates = [
      join(presetsDir, `${nameOrPath}.json`),
      join(presetsDir, nameOrPath),
    ];

    const found = candidates.find((p) => existsSync(p));
    if (!found) {
      throw new Error(
        `Preset "${nameOrPath}" not found. Searched:\n` +
        `  - ${resolvedPath}\n` +
        candidates.map((c) => `  - ${c}`).join("\n"),
      );
    }
    filePath = found;
  }

  const content = await Bun.file(filePath).text();
  let data: unknown;
  try {
    data = JSON.parse(content);
  } catch {
    throw new Error(`Invalid JSON in preset file: ${filePath}`);
  }

  const preset = validatePreset(data);

  const graphErrors = validateStepGraph(preset.steps);
  if (graphErrors.length > 0) {
    throw new Error(`Preset validation errors:\n${graphErrors.map((e) => `  - ${e}`).join("\n")}`);
  }

  return preset as Preset;
}

/** List all presets in the presets directory with metadata */
export async function listPresets(): Promise<Array<{
  name: string;
  fileName: string;
  description?: string;
  stepCount: number;
  meta: PresetMeta;
}>> {
  const presetsDir = getPresetsDir();
  if (!existsSync(presetsDir)) return [];

  const files = readdirSync(presetsDir).filter((f) => f.endsWith(".json"));
  const result: Array<{
    name: string;
    fileName: string;
    description?: string;
    stepCount: number;
    meta: PresetMeta;
  }> = [];

  for (const file of files) {
    try {
      const content = await Bun.file(join(presetsDir, file)).text();
      const data = JSON.parse(content);
      const preset = validatePreset(data);
      const meta = await getPresetMeta(preset.name);

      result.push({
        name: preset.name,
        fileName: file,
        description: preset.description,
        stepCount: preset.steps.length,
        meta,
      });
    } catch {
      // Skip invalid preset files silently
    }
  }

  return result;
}

/** Save a preset to the presets directory. Returns the file path. */
export async function savePreset(preset: Preset): Promise<string> {
  await ensureStorage();
  const fileName = preset.name
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, "-")
    .replace(/^-|-$/g, "");

  const filePath = join(getPresetsDir(), `${fileName}.json`);
  await Bun.write(filePath, JSON.stringify(preset, null, 2));
  return filePath;
}

/** Get metadata for a preset (last run date, run count) */
export async function getPresetMeta(presetName: string): Promise<PresetMeta> {
  const meta = await storage.getConfigValue<PresetMeta>(`meta.${presetName}`);
  return meta ?? {};
}

/** Update metadata after a successful run */
export async function updatePresetMeta(presetName: string): Promise<void> {
  const existing = await getPresetMeta(presetName);
  await storage.setConfigValue(`meta.${presetName}`, {
    lastRun: new Date().toISOString(),
    runCount: (existing.runCount ?? 0) + 1,
  });
}
```

**Step 2: Verify**

Run: `tsgo --noEmit 2>&1 | rg "automate/lib/storage"`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/automate/lib/storage.ts
git commit -m "feat(automate): add preset storage helpers wrapping Storage class"
```

---

### Task 5: Built-in Actions

**Files:**
- Create: `src/automate/lib/builtins.ts`

**Step 1: Write the code**

```typescript
// src/automate/lib/builtins.ts

import * as p from "@clack/prompts";
import type { ExecutionContext, PresetStep, StepResult } from "./types.ts";
import { resolveExpression, resolveParams } from "./expressions.ts";

/** The set of built-in action names that are handled directly (not via Bun.spawn) */
export const BUILTIN_ACTIONS = new Set(["if", "log", "prompt", "shell", "set"]);

/** Check if an action name is a built-in */
export function isBuiltinAction(action: string): boolean {
  return BUILTIN_ACTIONS.has(action);
}

/**
 * Execute a built-in action.
 * Returns the step result and optionally a "jumpTo" step ID (for `if` branching).
 */
export async function executeBuiltin(
  step: PresetStep,
  ctx: ExecutionContext,
): Promise<{ result: StepResult; jumpTo?: string }> {
  const start = Date.now();

  switch (step.action) {
    case "if":
      return handleIf(step, ctx, start);
    case "log":
      return handleLog(step, ctx, start);
    case "prompt":
      return handlePrompt(step, ctx, start);
    case "shell":
      return handleShell(step, ctx, start);
    case "set":
      return handleSet(step, ctx, start);
    default:
      throw new Error(`Unknown built-in action: "${step.action}"`);
  }
}

/** if -- evaluate condition expression, return jumpTo target step ID */
function handleIf(
  step: PresetStep,
  ctx: ExecutionContext,
  start: number,
): { result: StepResult; jumpTo?: string } {
  if (!step.condition) {
    throw new Error(`Step "${step.id}": "if" action requires a "condition" field`);
  }

  const conditionResult = resolveExpression(step.condition, ctx);
  const isTruthy = Boolean(conditionResult);
  const jumpTo = isTruthy ? step.then : step.else;

  return {
    result: {
      status: "success",
      output: isTruthy,
      duration: Date.now() - start,
    },
    jumpTo,
  };
}

/** log -- print a resolved message to console via @clack/prompts */
function handleLog(
  step: PresetStep,
  ctx: ExecutionContext,
  start: number,
): { result: StepResult } {
  const params = step.params
    ? resolveParams(step.params as Record<string, string | number | boolean | string[]>, ctx)
    : {};
  const message = String(params.message ?? "");

  p.log.info(message);

  return {
    result: {
      status: "success",
      output: message,
      duration: Date.now() - start,
    },
  };
}

/** prompt -- ask user a question interactively, store answer as output */
async function handlePrompt(
  step: PresetStep,
  ctx: ExecutionContext,
  start: number,
): Promise<{ result: StepResult }> {
  const params = step.params
    ? resolveParams(step.params as Record<string, string | number | boolean | string[]>, ctx)
    : {};
  const message = String(params.message ?? "Enter value:");
  const defaultValue = params.default != null ? String(params.default) : undefined;

  const answer = await p.text({
    message,
    placeholder: defaultValue,
    defaultValue,
  });

  if (p.isCancel(answer)) {
    return {
      result: {
        status: "error",
        output: null,
        duration: Date.now() - start,
        error: "User cancelled",
      },
    };
  }

  return {
    result: {
      status: "success",
      output: answer,
      duration: Date.now() - start,
    },
  };
}

/** shell -- run a raw shell command via bash, capture stdout/stderr */
async function handleShell(
  step: PresetStep,
  ctx: ExecutionContext,
  start: number,
): Promise<{ result: StepResult }> {
  const params = step.params
    ? resolveParams(step.params as Record<string, string | number | boolean | string[]>, ctx)
    : {};
  const command = String(params.command ?? params.cmd ?? "");

  if (!command) {
    throw new Error(`Step "${step.id}": "shell" action requires a "command" param`);
  }

  const cwd = params.cwd ? String(params.cwd) : process.cwd();

  const proc = Bun.spawn(["bash", "-c", command], {
    cwd,
    stdio: step.interactive ? ["inherit", "pipe", "pipe"] : ["ignore", "pipe", "pipe"],
    env: { ...process.env },
  });

  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const exitCode = await proc.exited;

  // Try to parse stdout as JSON for structured access
  let output: unknown = stdout.trim();
  try {
    output = JSON.parse(stdout);
  } catch {
    // Keep as raw string
  }

  return {
    result: {
      status: exitCode === 0 ? "success" : "error",
      output,
      exitCode,
      duration: Date.now() - start,
      error: exitCode !== 0 ? (stderr.trim() || `Exit code: ${exitCode}`) : undefined,
    },
  };
}

/** set -- set key-value pairs into ctx.vars */
function handleSet(
  step: PresetStep,
  ctx: ExecutionContext,
  start: number,
): { result: StepResult } {
  const params = step.params
    ? resolveParams(step.params as Record<string, string | number | boolean | string[]>, ctx)
    : {};

  for (const [key, value] of Object.entries(params)) {
    if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
      ctx.vars[key] = value;
    }
  }

  return {
    result: {
      status: "success",
      output: params,
      duration: Date.now() - start,
    },
  };
}
```

**Step 2: Verify**

Run: `tsgo --noEmit 2>&1 | rg "automate/lib/builtins"`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/automate/lib/builtins.ts
git commit -m "feat(automate): add built-in action handlers (if, log, prompt, shell, set)"
```

---

### Task 6: Step Runner

**Files:**
- Create: `src/automate/lib/step-runner.ts`

**Step 1: Write the code**

```typescript
// src/automate/lib/step-runner.ts

import { resolve } from "node:path";
import type { ExecutionContext, PresetStep, StepResult } from "./types.ts";
import { resolveParams } from "./expressions.ts";
import { executeBuiltin, isBuiltinAction } from "./builtins.ts";
import logger from "@app/logger.ts";

/**
 * Execute a single step.
 * - Built-in actions (if, log, prompt, shell, set) are dispatched to builtins.ts.
 * - Everything else is treated as a `tools <action>` command spawned via Bun.spawn.
 *
 * Returns the StepResult and an optional jumpTo step ID (from `if` actions).
 */
export async function executeStep(
  step: PresetStep,
  ctx: ExecutionContext,
  options: { dryRun?: boolean; verbose?: boolean },
): Promise<{ result: StepResult; jumpTo?: string }> {
  // Dispatch built-in actions
  if (isBuiltinAction(step.action)) {
    if (options.dryRun) {
      return {
        result: { status: "skipped", output: `[dry-run] built-in: ${step.action}`, duration: 0 },
      };
    }
    return executeBuiltin(step, ctx);
  }

  // Build the full tools command args
  const args = buildToolsArgs(step, ctx);

  if (options.dryRun) {
    return {
      result: {
        status: "skipped",
        output: `Would run: tools ${args.join(" ")}`,
        duration: 0,
      },
    };
  }

  if (options.verbose) {
    logger.debug(`Executing: tools ${args.join(" ")}`);
  }

  // Resolve path to the `tools` executable (3 dirs up from lib/ -> src/automate/lib/)
  const toolsPath = resolve(import.meta.dir, "../../../tools");
  const start = Date.now();

  const proc = Bun.spawn(["bun", "run", toolsPath, ...args], {
    cwd: process.cwd(),
    stdio: step.interactive
      ? ["inherit", "pipe", "pipe"]
      : ["ignore", "pipe", "pipe"],
    env: { ...process.env },
  });

  const stdout = await new Response(proc.stdout).text();
  const stderr = await new Response(proc.stderr).text();
  const exitCode = await proc.exited;

  // Try to parse stdout as JSON for structured access via expressions
  let output: unknown = stdout.trim();
  try {
    output = JSON.parse(stdout);
  } catch {
    // Keep as raw string
  }

  const result: StepResult = {
    status: exitCode === 0 ? "success" : "error",
    output,
    exitCode,
    duration: Date.now() - start,
    error: exitCode !== 0 ? (stderr.trim() || `Exit code: ${exitCode}`) : undefined,
  };

  return { result };
}

/**
 * Build CLI args array from step action + resolved params.
 *
 * The action string is split on whitespace to form the initial args.
 * Then params are appended:
 *   - Keys starting with "--" or "-" become flags.
 *     - Boolean true: flag is included. Boolean false: flag is omitted.
 *     - Arrays: joined with comma.
 *     - Other values: stringified.
 *   - Keys NOT starting with "-" are positional arguments (value only, key ignored).
 *
 * Example:
 *   action="github search", params={"query": "bug", "--repo": "owner/repo", "--format": "json"}
 *   => ["github", "search", "bug", "--repo", "owner/repo", "--format", "json"]
 */
function buildToolsArgs(step: PresetStep, ctx: ExecutionContext): string[] {
  const parts = step.action.split(/\s+/);

  if (!step.params) return parts;

  const resolved = resolveParams(
    step.params as Record<string, string | number | boolean | string[]>,
    ctx,
  );
  const args: string[] = [...parts];

  for (const [key, value] of Object.entries(resolved)) {
    if (key.startsWith("--") || key.startsWith("-")) {
      // Flag parameter
      if (typeof value === "boolean") {
        if (value) args.push(key);
        // false = omit the flag entirely
      } else if (Array.isArray(value)) {
        args.push(key, value.join(","));
      } else {
        args.push(key, String(value));
      }
    } else {
      // Positional parameter (key name like "query" is just a label)
      if (Array.isArray(value)) {
        args.push(...value.map(String));
      } else {
        args.push(String(value));
      }
    }
  }

  return args;
}
```

**Step 2: Verify**

Run: `tsgo --noEmit 2>&1 | rg "automate/lib/step-runner"`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/automate/lib/step-runner.ts
git commit -m "feat(automate): add step runner for tools command execution"
```

---

### Task 7: Execution Engine

**Files:**
- Create: `src/automate/lib/engine.ts`

**Step 1: Write the code**

```typescript
// src/automate/lib/engine.ts

import * as p from "@clack/prompts";
import pc from "picocolors";
import type { ExecutionContext, Preset, RunOptions, StepResult } from "./types.ts";
import { executeStep } from "./step-runner.ts";
import { updatePresetMeta } from "./storage.ts";
import { formatDuration } from "@app/utils/format.ts";
import logger from "@app/logger.ts";

export interface EngineResult {
  preset: string;
  success: boolean;
  steps: Array<{
    id: string;
    name: string;
    result: StepResult;
  }>;
  totalDuration: number;
}

/**
 * Execute a preset end-to-end.
 * 1. Build execution context from preset defaults + CLI overrides
 * 2. Prompt for missing required variables
 * 3. Walk the step array, executing each step
 * 4. Handle conditional jumps, error strategies, and output capture
 * 5. Update run metadata
 */
export async function runPreset(preset: Preset, options: RunOptions = {}): Promise<EngineResult> {
  const totalStart = Date.now();

  // Build initial context
  const ctx = buildContext(preset, options);

  // Prompt for any required vars that are missing
  await promptForMissingVars(preset, ctx);

  const results: EngineResult["steps"] = [];

  if (options.dryRun) {
    p.log.warn(pc.yellow("DRY RUN -- no commands will be executed"));
  }

  // Build a step-ID-to-index map for jump targets
  const stepIndex = new Map(preset.steps.map((s, i) => [s.id, i]));

  let i = 0;
  while (i < preset.steps.length) {
    const step = preset.steps[i];
    const stepLabel = `[${i + 1}/${preset.steps.length}] ${step.name}`;

    // --- Dry run: just log what would happen ---
    if (options.dryRun) {
      p.log.step(pc.dim(stepLabel));
      const { result } = await executeStep(step, ctx, { dryRun: true, verbose: options.verbose });
      if (typeof result.output === "string" && result.output) {
        p.log.info(pc.dim(`  ${result.output}`));
      }
      results.push({ id: step.id, name: step.name, result });
      i++;
      continue;
    }

    // --- Real execution with spinner ---
    const spinner = p.spinner();
    spinner.start(stepLabel);

    try {
      const { result, jumpTo } = await executeStep(step, ctx, {
        dryRun: false,
        verbose: options.verbose,
      });

      // Store result in context for subsequent expression references
      ctx.steps[step.id] = result;

      results.push({ id: step.id, name: step.name, result });

      if (result.status === "success") {
        spinner.stop(pc.green(`${stepLabel} (${formatDuration(result.duration)})`));
      } else if (result.status === "error") {
        spinner.stop(pc.red(`${stepLabel} FAILED`));

        if (result.error) {
          p.log.error(result.error);
        }

        const errorStrategy = step.onError ?? "stop";
        if (errorStrategy === "stop") {
          p.log.error("Stopping execution due to step failure (onError: stop)");
          break;
        }
        // "continue" and "skip" both move to next step
      }

      // Handle conditional jumps (from "if" action)
      if (jumpTo) {
        const targetIndex = stepIndex.get(jumpTo);
        if (targetIndex === undefined) {
          spinner.stop(pc.red(`${stepLabel} - jump target "${jumpTo}" not found`));
          break;
        }
        i = targetIndex;
        continue;
      }
    } catch (error) {
      spinner.stop(pc.red(`${stepLabel} EXCEPTION`));
      const errorMsg = error instanceof Error ? error.message : String(error);
      p.log.error(errorMsg);

      results.push({
        id: step.id,
        name: step.name,
        result: {
          status: "error",
          output: null,
          duration: Date.now() - totalStart,
          error: errorMsg,
        },
      });

      const errorStrategy = step.onError ?? "stop";
      if (errorStrategy === "stop") break;
    }

    i++;
  }

  const totalDuration = Date.now() - totalStart;
  const allSuccess = results.every(
    (r) => r.result.status === "success" || r.result.status === "skipped",
  );

  // Update run metadata (skip for dry runs)
  if (!options.dryRun) {
    try {
      await updatePresetMeta(preset.name);
    } catch {
      // Non-critical metadata update failure
    }
  }

  return {
    preset: preset.name,
    success: allSuccess,
    steps: results,
    totalDuration,
  };
}

/**
 * Build the initial execution context from preset variable defaults,
 * CLI --var overrides, and process.env.
 */
function buildContext(preset: Preset, options: RunOptions): ExecutionContext {
  const vars: Record<string, string | number | boolean> = {};

  // Apply defaults from preset variable definitions
  if (preset.vars) {
    for (const [key, def] of Object.entries(preset.vars)) {
      if (def.default !== undefined) {
        vars[key] = def.default;
      }
    }
  }

  // Apply CLI overrides (--var key=value)
  if (options.vars) {
    for (const varStr of options.vars) {
      const eqIndex = varStr.indexOf("=");
      if (eqIndex === -1) {
        p.log.warn(`Invalid --var format: "${varStr}" (expected key=value)`);
        continue;
      }
      const key = varStr.slice(0, eqIndex);
      const value = varStr.slice(eqIndex + 1);
      vars[key] = value;
    }
  }

  return {
    vars,
    steps: {},
    env: process.env as Record<string, string>,
  };
}

/**
 * Interactively prompt for any required variables that don't have a value yet.
 * Variables with `required: false` are skipped if missing.
 * Variables with a default value are pre-populated and not prompted.
 */
async function promptForMissingVars(
  preset: Preset,
  ctx: ExecutionContext,
): Promise<void> {
  if (!preset.vars) return;

  for (const [key, def] of Object.entries(preset.vars)) {
    // Already has a value (from default or CLI override)
    if (ctx.vars[key] !== undefined) continue;

    // Skip explicitly optional vars
    if (def.required === false) continue;

    // Prompt for the missing required variable
    const answer = await p.text({
      message: def.description || `Enter value for "${key}":`,
      placeholder: def.default != null ? String(def.default) : undefined,
      defaultValue: def.default != null ? String(def.default) : undefined,
    });

    if (p.isCancel(answer)) {
      p.cancel("Operation cancelled");
      process.exit(0);
    }

    // Coerce to the declared type
    if (def.type === "number") {
      ctx.vars[key] = Number(answer);
    } else if (def.type === "boolean") {
      ctx.vars[key] = answer === "true";
    } else {
      ctx.vars[key] = answer;
    }
  }
}
```

**Step 2: Verify**

Run: `tsgo --noEmit 2>&1 | rg "automate/lib/engine"`
Expected: No errors.

**Step 3: Commit**

```bash
git add src/automate/lib/engine.ts
git commit -m "feat(automate): add execution engine with progress, branching, error handling"
```

---

### Task 8: Entry Point

**Files:**
- Create: `src/automate/index.ts`

**Step 1: Write the code**

```typescript
#!/usr/bin/env bun

// src/automate/index.ts

import { Command } from "commander";
import * as p from "@clack/prompts";
import { handleReadmeFlag } from "@app/utils/readme.ts";
import { ensureStorage } from "@app/automate/lib/storage.ts";
import { registerRunCommand } from "@app/automate/commands/run.ts";
import { registerListCommand } from "@app/automate/commands/list.ts";
import { registerShowCommand } from "@app/automate/commands/show.ts";
import { registerCreateCommand } from "@app/automate/commands/create.ts";
import logger from "@app/logger.ts";

// Handle --readme flag early (before Commander parses)
handleReadmeFlag(import.meta.url);

const program = new Command();

program
  .name("automate")
  .description("Run and manage automation presets that chain GenesisTools commands")
  .version("1.0.0")
  .showHelpAfterError(true);

registerRunCommand(program);
registerListCommand(program);
registerShowCommand(program);
registerCreateCommand(program);

async function main(): Promise<void> {
  await ensureStorage();

  if (process.argv.length <= 2) {
    program.help();
    return;
  }

  try {
    await program.parseAsync(process.argv);
  } catch (error) {
    logger.error({ error }, "Automate command failed");
    p.log.error(error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}

main().catch((err) => {
  logger.error(`Unexpected error: ${err}`);
  process.exit(1);
});
```

**Step 2: Verify**

This step depends on the command files from Tasks 9-12, so we create empty stubs first.
Create `src/automate/commands/run.ts`, `list.ts`, `show.ts`, `create.ts` as empty stubs (they will be filled in the next tasks), then verify:

Run: `tools automate --help`
Expected: Shows help text with "run", "list", "show", "create" subcommands listed.

**Step 3: Commit**

```bash
git add src/automate/index.ts
git commit -m "feat(automate): add Commander entry point with subcommand registration"
```

---

### Task 9: `run` Command

**Files:**
- Create: `src/automate/commands/run.ts`

**Step 1: Write the code**

```typescript
// src/automate/commands/run.ts

import * as p from "@clack/prompts";
import pc from "picocolors";
import type { Command } from "commander";
import { loadPreset } from "@app/automate/lib/storage.ts";
import { runPreset } from "@app/automate/lib/engine.ts";
import { formatDuration } from "@app/utils/format.ts";

export function registerRunCommand(program: Command): void {
  program
    .command("run <preset>")
    .description("Run a preset by name or file path")
    .option("--dry-run", "Show what would execute without running")
    .option("--var <keyval...>", "Override variables (key=value)")
    .option("-v, --verbose", "Verbose output")
    .action(async (presetArg: string, opts: { dryRun?: boolean; var?: string[]; verbose?: boolean }) => {
      p.intro(pc.bgCyan(pc.black(" automate run ")));

      // Load preset
      const loadSpinner = p.spinner();
      loadSpinner.start("Loading preset...");

      let preset;
      try {
        preset = await loadPreset(presetArg);
        loadSpinner.stop(`Loaded: ${pc.bold(preset.name)}`);
      } catch (error) {
        loadSpinner.stop(pc.red("Failed to load preset"));
        p.log.error(error instanceof Error ? error.message : String(error));
        process.exit(1);
      }

      if (preset.description) {
        p.log.info(pc.dim(preset.description));
      }

      // Execute the preset
      const result = await runPreset(preset, {
        dryRun: opts.dryRun,
        vars: opts.var,
        verbose: opts.verbose,
      });

      // Summary
      const successCount = result.steps.filter((s) => s.result.status === "success").length;
      const failCount = result.steps.filter((s) => s.result.status === "error").length;
      const skipCount = result.steps.filter((s) => s.result.status === "skipped").length;

      const summaryParts: string[] = [];
      if (successCount > 0) summaryParts.push(pc.green(`${successCount} passed`));
      if (failCount > 0) summaryParts.push(pc.red(`${failCount} failed`));
      if (skipCount > 0) summaryParts.push(pc.dim(`${skipCount} skipped`));

      p.outro(
        result.success
          ? pc.green(`Done in ${formatDuration(result.totalDuration)} (${summaryParts.join(", ")})`)
          : pc.red(`Failed after ${formatDuration(result.totalDuration)} (${summaryParts.join(", ")})`),
      );

      if (!result.success) process.exit(1);
    });
}
```

**Step 2: Verify**

Run: `tools automate run --help`
Expected: Shows usage with `<preset>`, `--dry-run`, `--var`, `-v` options listed.

**Step 3: Commit**

```bash
git add src/automate/commands/run.ts
git commit -m "feat(automate): add 'run' command with dry-run and variable overrides"
```

---

### Task 10: `list` Command

**Files:**
- Create: `src/automate/commands/list.ts`

**Step 1: Write the code**

```typescript
// src/automate/commands/list.ts

import * as p from "@clack/prompts";
import pc from "picocolors";
import type { Command } from "commander";
import { ensureStorage, listPresets } from "@app/automate/lib/storage.ts";
import { formatRelativeTime } from "@app/utils/format.ts";

export function registerListCommand(program: Command): void {
  program
    .command("list")
    .alias("ls")
    .description("List all available presets")
    .action(async () => {
      p.intro(pc.bgCyan(pc.black(" automate list ")));

      await ensureStorage();
      const presets = await listPresets();

      if (presets.length === 0) {
        p.log.warn("No presets found.");
        p.log.info(`Create one with: ${pc.cyan("tools automate create")}`);
        p.log.info(`Or save a JSON file to: ${pc.dim("~/.genesis-tools/automate/presets/")}`);
        p.outro("");
        return;
      }

      for (const preset of presets) {
        const lastRun = preset.meta.lastRun
          ? formatRelativeTime(new Date(preset.meta.lastRun).getTime())
          : pc.dim("never");

        p.log.info(
          `${pc.bold(preset.name)} ${pc.dim(`(${preset.fileName})`)}\n` +
          (preset.description ? `  ${preset.description}\n` : "") +
          `  ${pc.dim("Steps:")} ${preset.stepCount}  ${pc.dim("Last run:")} ${lastRun}` +
          (preset.meta.runCount ? `  ${pc.dim("Runs:")} ${preset.meta.runCount}` : ""),
        );
      }

      p.outro(`${presets.length} preset(s) found`);
    });
}
```

**Step 2: Verify**

Run: `tools automate list`
Expected: Shows "No presets found." with create instructions (until presets are saved).

**Step 3: Commit**

```bash
git add src/automate/commands/list.ts
git commit -m "feat(automate): add 'list' command to show available presets"
```

---

### Task 11: `show` Command

**Files:**
- Create: `src/automate/commands/show.ts`

**Step 1: Write the code**

```typescript
// src/automate/commands/show.ts

import * as p from "@clack/prompts";
import pc from "picocolors";
import type { Command } from "commander";
import { getPresetMeta, loadPreset } from "@app/automate/lib/storage.ts";
import { isBuiltinAction } from "@app/automate/lib/builtins.ts";
import { formatRelativeTime } from "@app/utils/format.ts";

export function registerShowCommand(program: Command): void {
  program
    .command("show <preset>")
    .description("Show preset details (variables, steps, metadata)")
    .action(async (presetArg: string) => {
      p.intro(pc.bgCyan(pc.black(" automate show ")));

      let preset;
      try {
        preset = await loadPreset(presetArg);
      } catch (error) {
        p.log.error(error instanceof Error ? error.message : String(error));
        process.exit(1);
      }

      // Header
      p.log.info(pc.bold(preset.name));
      if (preset.description) {
        p.log.info(pc.dim(preset.description));
      }

      // Variables
      if (preset.vars && Object.keys(preset.vars).length > 0) {
        p.log.step(pc.underline("Variables:"));
        for (const [key, def] of Object.entries(preset.vars)) {
          const defaultStr = def.default != null
            ? pc.dim(` = ${def.default}`)
            : pc.yellow(" (required)");
          p.log.info(`  ${pc.cyan(key)} (${def.type})${defaultStr}`);
          if (def.description) {
            p.log.info(`    ${pc.dim(def.description)}`);
          }
        }
      }

      // Steps
      p.log.step(pc.underline("Steps:"));
      for (let i = 0; i < preset.steps.length; i++) {
        const step = preset.steps[i];
        const isBuiltin = isBuiltinAction(step.action);
        const actionLabel = isBuiltin
          ? pc.magenta(step.action)
          : pc.cyan(`tools ${step.action}`);

        const flags: string[] = [];
        if (step.interactive) flags.push(pc.yellow("interactive"));
        if (step.onError && step.onError !== "stop") flags.push(pc.dim(`onError:${step.onError}`));
        if (step.output) flags.push(pc.dim(`-> ${step.output}`));

        p.log.info(
          `  ${pc.dim(`${i + 1}.`)} ${pc.bold(step.name)} ${pc.dim(`(${step.id})`)}\n` +
          `     ${actionLabel}${flags.length > 0 ? ` [${flags.join(", ")}]` : ""}`,
        );
      }

      // Metadata
      const meta = await getPresetMeta(preset.name);
      if (meta.lastRun) {
        p.log.step(pc.underline("History:"));
        p.log.info(`  Last run: ${formatRelativeTime(new Date(meta.lastRun).getTime())}`);
        p.log.info(`  Total runs: ${meta.runCount ?? 0}`);
      }

      p.outro("");
    });
}
```

**Step 2: Verify**

Run: `tools automate show --help`
Expected: Shows usage with `<preset>` argument.

**Step 3: Commit**

```bash
git add src/automate/commands/show.ts
git commit -m "feat(automate): add 'show' command to display preset details"
```

---

### Task 12: `create` Command

**Files:**
- Create: `src/automate/commands/create.ts`

**Step 1: Write the code**

```typescript
// src/automate/commands/create.ts

import * as p from "@clack/prompts";
import pc from "picocolors";
import type { Command } from "commander";
import type { Preset, PresetStep } from "@app/automate/lib/types.ts";
import { savePreset } from "@app/automate/lib/storage.ts";

export function registerCreateCommand(program: Command): void {
  program
    .command("create")
    .description("Interactive preset creator wizard")
    .action(async () => {
      p.intro(pc.bgCyan(pc.black(" automate create ")));

      // 1. Name & description
      const name = await p.text({
        message: "Preset name:",
        placeholder: "My Automation",
        validate: (v) => (v.length === 0 ? "Name is required" : undefined),
      });
      if (p.isCancel(name)) { p.cancel("Cancelled"); process.exit(0); }

      const description = await p.text({
        message: "Description (optional):",
        placeholder: "What does this preset do?",
      });
      if (p.isCancel(description)) { p.cancel("Cancelled"); process.exit(0); }

      // 2. Add steps in a loop
      const steps: PresetStep[] = [];
      let addMore = true;

      while (addMore) {
        p.log.step(pc.bold(`Step ${steps.length + 1}`));

        const actionType = await p.select({
          message: "Action type:",
          options: [
            { value: "tools", label: "Tools command (tools <cmd>)" },
            { value: "shell", label: "Shell command" },
            { value: "if", label: "Conditional (if/then/else)" },
            { value: "log", label: "Log a message" },
            { value: "prompt", label: "Ask user a question" },
            { value: "set", label: "Set a variable" },
          ],
        });
        if (p.isCancel(actionType)) { p.cancel("Cancelled"); process.exit(0); }

        const stepId = await p.text({
          message: "Step ID (unique, alphanumeric):",
          placeholder: `step-${steps.length + 1}`,
          defaultValue: `step-${steps.length + 1}`,
          validate: (v) => {
            if (!/^[a-zA-Z0-9_-]+$/.test(v)) return "Must be alphanumeric with hyphens/underscores";
            if (steps.some((s) => s.id === v)) return "ID already used";
            return undefined;
          },
        });
        if (p.isCancel(stepId)) { p.cancel("Cancelled"); process.exit(0); }

        const stepName = await p.text({
          message: "Step display name:",
          placeholder: "What this step does",
        });
        if (p.isCancel(stepName)) { p.cancel("Cancelled"); process.exit(0); }

        let step: PresetStep;

        if (actionType === "tools") {
          const action = await p.text({
            message: "Tools command (without 'tools' prefix):",
            placeholder: "github search",
          });
          if (p.isCancel(action)) { p.cancel("Cancelled"); process.exit(0); }
          step = { id: stepId, name: stepName, action };
        } else if (actionType === "shell") {
          const command = await p.text({
            message: "Shell command:",
            placeholder: "ls -la",
          });
          if (p.isCancel(command)) { p.cancel("Cancelled"); process.exit(0); }
          step = { id: stepId, name: stepName, action: "shell", params: { command } };
        } else if (actionType === "if") {
          const condition = await p.text({
            message: "Condition expression (without {{ }}):",
            placeholder: "steps.prev.output.count > 0",
          });
          if (p.isCancel(condition)) { p.cancel("Cancelled"); process.exit(0); }

          const thenStep = await p.text({
            message: "Jump to step on TRUE (step ID):",
            placeholder: "step-3",
          });
          if (p.isCancel(thenStep)) { p.cancel("Cancelled"); process.exit(0); }

          const elseStep = await p.text({
            message: "Jump to step on FALSE (optional, step ID):",
            placeholder: "step-4",
          });
          if (p.isCancel(elseStep)) { p.cancel("Cancelled"); process.exit(0); }

          step = {
            id: stepId,
            name: stepName,
            action: "if",
            condition: `{{ ${condition} }}`,
            then: thenStep || undefined,
            else: elseStep || undefined,
          };
        } else if (actionType === "log") {
          const message = await p.text({
            message: "Message to log:",
            placeholder: "Processing {{ vars.name }}...",
          });
          if (p.isCancel(message)) { p.cancel("Cancelled"); process.exit(0); }
          step = { id: stepId, name: stepName, action: "log", params: { message } };
        } else if (actionType === "prompt") {
          const message = await p.text({
            message: "Prompt message:",
            placeholder: "Enter your name:",
          });
          if (p.isCancel(message)) { p.cancel("Cancelled"); process.exit(0); }
          step = { id: stepId, name: stepName, action: "prompt", params: { message } };
        } else {
          // "set"
          const setKey = await p.text({
            message: "Variable name to set:",
            placeholder: "myVar",
          });
          if (p.isCancel(setKey)) { p.cancel("Cancelled"); process.exit(0); }

          const setValue = await p.text({
            message: "Value (can use {{ expressions }}):",
            placeholder: "{{ steps.prev.output }}",
          });
          if (p.isCancel(setValue)) { p.cancel("Cancelled"); process.exit(0); }
          step = { id: stepId, name: stepName, action: "set", params: { [setKey]: setValue } };
        }

        // Option to store output
        const storeOutput = await p.confirm({
          message: "Store step output in a variable?",
          initialValue: false,
        });
        if (p.isCancel(storeOutput)) { p.cancel("Cancelled"); process.exit(0); }

        if (storeOutput) {
          const outputName = await p.text({
            message: "Output variable name:",
            placeholder: stepId,
            defaultValue: stepId,
          });
          if (p.isCancel(outputName)) { p.cancel("Cancelled"); process.exit(0); }
          step.output = outputName;
        }

        steps.push(step);

        const continueAdding = await p.confirm({
          message: "Add another step?",
          initialValue: true,
        });
        if (p.isCancel(continueAdding)) { p.cancel("Cancelled"); process.exit(0); }
        addMore = continueAdding;
      }

      // 3. Build the preset object
      const preset: Preset = {
        $schema: "genesis-tools-preset-v1",
        name,
        description: description || undefined,
        trigger: { type: "manual" },
        steps,
      };

      // 4. Preview
      p.log.step("Preview:");
      p.log.info(pc.dim(JSON.stringify(preset, null, 2)));

      // 5. Save
      const shouldSave = await p.confirm({
        message: "Save this preset?",
        initialValue: true,
      });
      if (p.isCancel(shouldSave) || !shouldSave) {
        p.cancel("Preset not saved");
        process.exit(0);
      }

      const filePath = await savePreset(preset);
      p.outro(pc.green(`Saved to: ${filePath}`));
    });
}
```

**Step 2: Verify**

Run: `tools automate create --help`
Expected: Shows description "Interactive preset creator wizard".

**Step 3: Commit**

```bash
git add src/automate/commands/create.ts
git commit -m "feat(automate): add interactive 'create' wizard for building presets"
```

---

### Task 13: Example Presets

**Files:**
- Create: `~/.genesis-tools/automate/presets/hello-automate.json` (via the tool or manually)
- Create: `~/.genesis-tools/automate/presets/monthly-invoice-search.json`

**Step 1: Save hello-automate preset**

Write the following to `~/.genesis-tools/automate/presets/hello-automate.json`:

```json
{
  "$schema": "genesis-tools-preset-v1",
  "name": "Hello Automate",
  "description": "Simple test preset to verify the framework works",
  "trigger": { "type": "manual" },
  "vars": {
    "name": { "type": "string", "description": "Your name", "default": "World" }
  },
  "steps": [
    {
      "id": "greet",
      "name": "Say hello",
      "action": "log",
      "params": { "message": "Hello, {{ vars.name }}!" }
    },
    {
      "id": "date",
      "name": "Show current date",
      "action": "shell",
      "params": { "command": "date '+%Y-%m-%d %H:%M:%S'" },
      "output": "currentDate"
    },
    {
      "id": "summary",
      "name": "Show summary",
      "action": "log",
      "params": { "message": "Completed at {{ steps.date.output }}" }
    }
  ]
}
```

**Step 2: Save monthly-invoice-search preset**

Write the following to `~/.genesis-tools/automate/presets/monthly-invoice-search.json`:

```json
{
  "$schema": "genesis-tools-preset-v1",
  "name": "Monthly Invoice Search",
  "description": "Search Mail.app for invoices and download as markdown",
  "trigger": { "type": "manual" },
  "vars": {
    "startDate": { "type": "string", "description": "Start date (YYYY-MM-DD)", "default": "2026-01-01" },
    "outputDir": { "type": "string", "description": "Output directory", "default": "./invoices" }
  },
  "steps": [
    {
      "id": "search",
      "name": "Search Mail for Invoices",
      "action": "macos-mail search",
      "params": {
        "query": "invoice OR faktura OR receipt",
        "--from": "{{ vars.startDate }}",
        "--format": "json"
      },
      "output": "searchResults",
      "onError": "stop"
    },
    {
      "id": "check",
      "name": "Check if results found",
      "action": "if",
      "condition": "{{ steps.search.output.count > 0 }}",
      "then": "download",
      "else": "no-results"
    },
    {
      "id": "download",
      "name": "Download Invoices",
      "action": "macos-mail download",
      "params": {
        "--ids": "{{ steps.search.output.ids }}",
        "--dir": "{{ vars.outputDir }}",
        "--save-attachments": true
      },
      "interactive": true,
      "onError": "stop"
    },
    {
      "id": "no-results",
      "name": "No Results",
      "action": "log",
      "params": { "message": "No invoices found for period starting {{ vars.startDate }}" }
    }
  ]
}
```

**Step 3: Verify**

Run the following commands to test the framework end-to-end:

```bash
# Basic run with default variable
tools automate run hello-automate

# With variable override
tools automate run hello-automate --var name=Martin

# Dry run
tools automate run hello-automate --dry-run

# List presets
tools automate list

# Show preset details
tools automate show hello-automate
```

Expected for `tools automate run hello-automate --var name=Martin`:
```
 automate run
 Loaded: Hello Automate
 [1/3] Say hello (Xms)
   Hello, Martin!
 [2/3] Show current date (Xms)
 [3/3] Show summary (Xms)
   Completed at 2026-02-16 HH:MM:SS
 Done in X.Xs (3 passed)
```

**Step 4: Commit**

No git commit for this task (preset files are in `~/.genesis-tools/`, not in the repo).

---

### Task 14: Claude Code Skill

**Files:**
- Create: `plugins/genesis-tools/skills/automate/SKILL.md`

**Step 1: Write the code**

```markdown
---
name: genesis-tools:automate
description: |
  Create and run automation presets using the `tools automate` CLI.
  Use when:
  - User wants to automate a repetitive workflow
  - User says "automate", "create automation", "run preset"
  - User wants to chain multiple tools commands together
  - User asks to create a reusable workflow
  - User wants to run a previously saved preset
---

# Automate Tool Usage Guide

Create and run reusable automation presets that chain GenesisTools commands.

## Quick Reference

| Task | Command |
|------|---------|
| Run a preset | `tools automate run <name-or-path>` |
| Run with overrides | `tools automate run <name> --var startDate=2026-02-01` |
| Dry run (preview) | `tools automate run <name> --dry-run` |
| List presets | `tools automate list` |
| Show preset details | `tools automate show <name>` |
| Create interactively | `tools automate create` |

## Creating Presets via Conversation

When a user wants to create an automation, help them build the JSON preset:

1. **Identify the workflow steps** -- What tools commands do they need?
2. **Identify variables** -- What values change between runs?
3. **Identify conditions** -- Are there any if/else branches?
4. **Build the JSON** -- Write the preset file
5. **Save it** -- Write to `~/.genesis-tools/automate/presets/<name>.json`

## Preset JSON Format (Full Schema)

```json
{
  "$schema": "genesis-tools-preset-v1",
  "name": "Preset Name",
  "description": "What this preset does",
  "trigger": { "type": "manual" },
  "vars": {
    "varName": {
      "type": "string",
      "description": "Human description",
      "default": "value",
      "required": true
    }
  },
  "steps": [
    {
      "id": "unique-step-id",
      "name": "Human-readable name",
      "action": "github search",
      "params": {
        "query": "search term",
        "--repo": "owner/repo",
        "--format": "json"
      },
      "output": "resultVar",
      "onError": "stop",
      "interactive": false
    }
  ]
}
```

### Variable Types
- `"string"` -- text values
- `"number"` -- numeric values
- `"boolean"` -- true/false

### Error Strategies (`onError`)
- `"stop"` (default) -- halt execution on failure
- `"continue"` -- log error and proceed to next step
- `"skip"` -- silently skip and proceed

## Expression Syntax

Expressions use `{{ }}` delimiters and are resolved at runtime:

| Expression | Purpose | Example |
|------------|---------|---------|
| `{{ vars.name }}` | Reference a preset variable | `{{ vars.startDate }}` |
| `{{ steps.id.output }}` | Previous step's full output | `{{ steps.search.output }}` |
| `{{ steps.id.output.field }}` | Nested output field | `{{ steps.search.output.count }}` |
| `{{ env.HOME }}` | Environment variable | `{{ env.USER }}` |
| `{{ expr > 0 }}` | Boolean expression | `{{ steps.x.output.count > 0 }}` |

When the entire value is a single expression, the raw type is preserved (boolean, number, object).
When expressions are embedded in a larger string, they are interpolated as strings.

## Built-in Actions

| Action | Purpose | Key Params |
|--------|---------|------------|
| `if` | Conditional branch | `condition` (required), `then`, `else` (step IDs to jump to) |
| `log` | Print a message | `message` |
| `prompt` | Ask user for input | `message`, `default` |
| `shell` | Run a raw shell command | `command` (required), `cwd` (optional) |
| `set` | Set variables in context | Any key=value pairs in params |

## Action Format for Tools Commands

The `action` field maps directly to `tools <action>`:
- `"action": "github search"` => runs `tools github search`
- `"action": "collect-files-for-ai"` => runs `tools collect-files-for-ai`
- `"action": "azure-devops workitem"` => runs `tools azure-devops workitem`

### Param Conventions
- Keys starting with `--` or `-` become CLI flags
- Boolean `true` includes the flag, `false` omits it
- Array values are joined with commas
- Other keys are treated as positional arguments (the key name is a label, only the value is passed)

## Examples

### Simple: Run a shell command and log result
```json
{
  "$schema": "genesis-tools-preset-v1",
  "name": "Hello Automate",
  "trigger": { "type": "manual" },
  "vars": {
    "name": { "type": "string", "description": "Your name", "default": "World" }
  },
  "steps": [
    { "id": "greet", "name": "Say hello", "action": "log", "params": { "message": "Hello, {{ vars.name }}!" } },
    { "id": "date", "name": "Get date", "action": "shell", "params": { "command": "date '+%Y-%m-%d'" }, "output": "currentDate" },
    { "id": "done", "name": "Summary", "action": "log", "params": { "message": "Done at {{ steps.date.output }}" } }
  ]
}
```

### With Branching: Search and conditionally download
```json
{
  "$schema": "genesis-tools-preset-v1",
  "name": "Monthly Invoice Search",
  "trigger": { "type": "manual" },
  "vars": {
    "startDate": { "type": "string", "description": "Start date", "default": "2026-01-01" }
  },
  "steps": [
    { "id": "search", "name": "Search Mail", "action": "macos-mail search", "params": { "query": "invoice", "--from": "{{ vars.startDate }}", "--format": "json" }, "output": "results" },
    { "id": "check", "name": "Has results?", "action": "if", "condition": "{{ steps.search.output.count > 0 }}", "then": "download", "else": "empty" },
    { "id": "download", "name": "Download", "action": "macos-mail download", "params": { "--ids": "{{ steps.search.output.ids }}" } },
    { "id": "empty", "name": "No results", "action": "log", "params": { "message": "Nothing found." } }
  ]
}
```

## Running Presets

```bash
# By name (looks in ~/.genesis-tools/automate/presets/)
tools automate run monthly-invoice-search

# By file path
tools automate run ./my-preset.json

# With variable overrides
tools automate run monthly-invoice-search --var startDate=2026-02-01 --var outputDir=/tmp/invoices

# Dry run (shows what would execute without running)
tools automate run monthly-invoice-search --dry-run
```

## Storage

- Presets: `~/.genesis-tools/automate/presets/*.json`
- Config/metadata: `~/.genesis-tools/automate/config.json`
- Run metadata tracks last run date and total run count per preset
```

**Step 2: Verify**

Run: `ls plugins/genesis-tools/skills/automate/SKILL.md`
Expected: File exists.

**Step 3: Commit**

```bash
git add plugins/genesis-tools/skills/automate/SKILL.md
git commit -m "feat(automate): add Claude Code skill for preset creation and execution"
```

---

## Implementation Order

```
Task  1: types.ts          (no deps)
Task  2: schema.ts         (depends on Task 1)
Task  3: expressions.ts    (depends on Task 1)
Task  4: storage.ts        (depends on Task 1, 2)
Task  5: builtins.ts       (depends on Task 1, 3)
Task  6: step-runner.ts    (depends on Task 1, 3, 5)
Task  7: engine.ts         (depends on Task 1, 4, 6)
Task  8: index.ts          (depends on Task 9-12 stubs)
Task  9: run.ts            (depends on Task 4, 7)
Task 10: list.ts           (depends on Task 4)
Task 11: show.ts           (depends on Task 4, 5)
Task 12: create.ts         (depends on Task 1, 4)
Task 13: Example presets   (depends on Task 8)
Task 14: SKILL.md          (standalone, do anytime)
```

**Recommended build order:** 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10 -> 11 -> 12 -> 13 -> 14

After Task 8, run `tools automate --help` to confirm Commander is wired up.
After Task 13, run the hello-automate preset to verify the full execution pipeline.

---

## Testing Strategy

No formal test suite (per project conventions). Manual verification at each checkpoint:

1. **After Task 8:** `tools automate --help` shows subcommands
2. **After Task 13 (hello preset):**
   ```bash
   tools automate run hello-automate
   tools automate run hello-automate --var name=Martin
   tools automate run hello-automate --dry-run
   ```
3. **After Task 10:** `tools automate list` shows saved presets
4. **After Task 11:** `tools automate show hello-automate` displays variables and steps
5. **After Task 12:** `tools automate create` walks through the wizard

### Expression edge cases to verify:
- `{{ vars.missing }}` resolves to empty string (not crash)
- `{{ steps.nonexistent.output }}` resolves to undefined
- Nested access: `{{ steps.search.output.items[0].name }}` works via Function()
- Boolean condition: `{{ steps.check.output === true }}` returns boolean

### Error handling to verify:
- Invalid preset JSON shows Zod validation errors
- Missing required variable prompts interactively
- Step failure with `onError: "stop"` halts execution
- Step failure with `onError: "continue"` proceeds to next step
- Duplicate step IDs are caught by `validateStepGraph`
- `if` referencing nonexistent step ID is caught

---

## Design Notes

1. **Step output parsing:** Step runner tries `JSON.parse()` on stdout. If it fails, the raw trimmed string is kept. Tools commands that output `--format json` will produce structured data accessible via `steps.id.output.field`.

2. **Interactive steps:** When `interactive: true`, the subprocess inherits stdin so the user can interact with prompts. Stdout is still piped for output capture. Tradeoff: interactive steps that mix prompts with data on stdout may not have clean output capture.

3. **Conditional jumps:** The `if` built-in returns a `jumpTo` step ID. The engine resolves it to an array index and jumps directly. Supports both forward and backward jumps. No infinite loop protection in v1.

4. **Expression security:** Uses `new Function()` for complex expressions. Acceptable for a local CLI tool where the user authors their own presets. Not suitable for executing untrusted preset files.

5. **Tools path resolution:** `step-runner.ts` resolves the `tools` executable via `resolve(import.meta.dir, "../../../tools")` which maps from `src/automate/lib/` up to the project root.

6. **Context structure:** `ctx.steps[id]` stores the full `StepResult` object, so `steps.search.output` naturally resolves because `StepResult` has an `output` field. The expression evaluator traverses this via dot-path access or Function evaluation.
