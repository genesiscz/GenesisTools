#!/usr/bin/env bun

import clipboardy from "clipboardy";
import Enquirer from "enquirer";
import { spawnSync } from "node:child_process";
import { existsSync, readdirSync, statSync } from "node:fs";
import { basename, join, resolve } from "node:path";
import logger from "./src/logger";

// --- Configuration ---
const SRC_DIR_NAME = "src";
const INDEX_FILE_NAMES = ["index.ts", "index.tsx"];
const SCRIPT_EXTENSIONS = [".ts", ".tsx"];
const EXECUTABLE_NAME = "tools"; // How this script is invoked

// --- Helper Functions ---
async function getAvailableTools(srcDir) {
    const tools = [];
    try {
        const entries = readdirSync(srcDir);
        for (const entry of entries) {
            const entryPath = join(srcDir, entry);
            try {
                const stats = statSync(entryPath);
                if (stats.isDirectory()) {
                    // Check for index.ts or index.tsx inside the directory
                    const hasIndexFile = INDEX_FILE_NAMES.some((indexFile) => {
                        const indexFilePath = join(entryPath, indexFile);
                        return existsSync(indexFilePath);
                    });
                    if (hasIndexFile) {
                        tools.push(entry); // Tool name is the directory name
                    }
                } else if (
                    stats.isFile() &&
                    SCRIPT_EXTENSIONS.some((ext) => entry.endsWith(ext)) &&
                    !INDEX_FILE_NAMES.includes(entry)
                ) {
                    // Add .ts/.tsx files directly in src (excluding index.ts)
                    const ext = SCRIPT_EXTENSIONS.find((ext) => entry.endsWith(ext));
                    tools.push(basename(entry, ext));
                }
            } catch (statError) {
                // Ignore errors for individual entries (e.g., permission issues)
                // logger.warn(`Warning: Could not stat entry ${entryPath}:`, statError);
            }
        }
    } catch (readError) {
        logger.error(`✖ Error reading source directory ${srcDir}:`, readError);
    }
    return tools.sort(); // Return sorted list
}

async function selectToolAndCopyCommand(tools) {
    if (tools.length === 0) {
        logger.info("ℹ️ No tools found in the src directory.");
        process.exit(0);
    }

    try {
        // Note: Enquirer might infer the type here, but explicitly removing <{ tool: string }>
        const prompter = new Enquirer();
        const response = await prompter.prompt({
            type: "autocomplete",
            name: "tool",
            message: "Select a tool to copy its command:",
            choices: tools,
            limit: 10, // Show up to 10 choices at once
        });

        // Check if response and response.tool exist (JS style)
        if (response && response.tool) {
            const commandToCopy = `${EXECUTABLE_NAME} ${response.tool}`;
            await clipboardy.write(commandToCopy);
            logger.info(`✔ Command "${commandToCopy}" copied to clipboard!`);
        } else {
            logger.info("✖ Tool selection cancelled.");
        }
    } catch (error) {
        // instanceof check works fine in JS
        if (error instanceof Error && error.message === "User aborted") {
            logger.info("\n✖ Tool selection cancelled.");
        } else {
            logger.error("\n✖ An error occurred during tool selection:", error);
        }
        process.exit(1); // Exit on error or cancellation
    }
}

function executeTool(scriptId, scriptArgs) {
    const workspaceRoot = resolve(__dirname); // Assumes the script is run from the root
    const srcDir = join(workspaceRoot, SRC_DIR_NAME);

    // Potential paths
    const pathAsIs = join(srcDir, scriptId); // Handles cases where extension is already included by user

    let targetScript = "";

    // Check existence in order of preference - first check for index files in directory
    let pathDirIndex = "";
    for (const indexFile of INDEX_FILE_NAMES) {
        const potentialPath = join(srcDir, scriptId, indexFile);
        if (existsSync(potentialPath)) {
            pathDirIndex = potentialPath;
            break;
        }
    }

    if (pathDirIndex) {
        targetScript = pathDirIndex;
    } else if (existsSync(pathAsIs) && SCRIPT_EXTENSIONS.some((ext) => pathAsIs.endsWith(ext))) {
        // Check if user provided path with valid extension
        targetScript = pathAsIs;
    } else {
        // Try each extension
        for (const ext of SCRIPT_EXTENSIONS) {
            const pathWithExt = join(srcDir, `${scriptId}${ext}`);
            if (existsSync(pathWithExt)) {
                targetScript = pathWithExt;
                break;
            }
        }

        if (!targetScript) {
            logger.error(`✖ Error: Could not find a script matching '${scriptId}'.`);
            logger.error("Looked for:");
            INDEX_FILE_NAMES.forEach((indexFile) => {
                logger.error(`  - ${join(srcDir, scriptId, indexFile)}`);
            });
            SCRIPT_EXTENSIONS.forEach((ext) => {
                logger.error(`  - ${join(srcDir, `${scriptId}${ext}`)}`);
            });
            logger.error(`  - ${pathAsIs} (if it ends with ${SCRIPT_EXTENSIONS.join(" or ")})`);
            process.exit(1);
        }
    }

    logger.debug(`▶️ Running: bun run ${targetScript} ${scriptArgs.join(" ")}`);

    // Execute bun run using spawnSync
    const result = spawnSync("bun", ["run", targetScript, ...scriptArgs], {
        stdio: "inherit",
        cwd: process.cwd(),
        shell: process.platform === "win32",
    });

    process.exit(result.status ?? 1);
}

// --- Main Logic ---
async function main() {
    const args = process.argv.slice(2);
    const workspaceRoot = resolve(__dirname);
    const srcDir = join(workspaceRoot, SRC_DIR_NAME);

    if (args.length === 0) {
        // No arguments: Show interactive tool list
        logger.info("ℹ️ No tool specified. Listing available tools...");
        const availableTools = await getAvailableTools(srcDir);
        await selectToolAndCopyCommand(availableTools);
    } else {
        // Arguments provided: Execute the tool
        const scriptId = args[0];
        const scriptArgs = args.slice(1);
        executeTool(scriptId, scriptArgs);
    }
}

main().catch((err) => {
    logger.error("\n✖ An unexpected error occurred in the main execution:", err);
    process.exit(1);
});
