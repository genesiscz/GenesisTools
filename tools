#!/usr/bin/env bun

import { search } from "@inquirer/prompts";
import { ExitPromptError } from "@inquirer/core";
import { spawnSync } from "node:child_process";
import { existsSync, readdirSync, statSync } from "node:fs";
import { basename, join, resolve } from "node:path";
import logger from "@app/logger";

// --- Configuration ---
const SRC_DIR_NAME = "src";
const INDEX_FILE_NAMES = ["index.ts", "index.tsx"];
const SCRIPT_EXTENSIONS = [".ts", ".tsx"];

// --- Helper Functions ---
async function getAvailableTools(srcDir) {
    const tools = [];
    try {
        const entries = readdirSync(srcDir);
        for (const entry of entries) {
            const entryPath = join(srcDir, entry);
            try {
                const stats = statSync(entryPath);
                if (stats.isDirectory()) {
                    // Check for index.ts or index.tsx inside the directory
                    const hasIndexFile = INDEX_FILE_NAMES.some((indexFile) => {
                        const indexFilePath = join(entryPath, indexFile);
                        return existsSync(indexFilePath);
                    });
                    if (hasIndexFile) {
                        tools.push(entry); // Tool name is the directory name
                    }
                } else if (
                    stats.isFile() &&
                    SCRIPT_EXTENSIONS.some((ext) => entry.endsWith(ext)) &&
                    !INDEX_FILE_NAMES.includes(entry)
                ) {
                    // Add .ts/.tsx files directly in src (excluding index.ts)
                    const ext = SCRIPT_EXTENSIONS.find((ext) => entry.endsWith(ext));
                    tools.push(basename(entry, ext));
                }
            } catch (statError) {
                // Ignore errors for individual entries (e.g., permission issues)
                // logger.warn(`Warning: Could not stat entry ${entryPath}:`, statError);
            }
        }
    } catch (readError) {
        logger.error(`✖ Error reading source directory ${srcDir}:`, readError);
    }
    return tools.sort(); // Return sorted list
}

async function executeTool(scriptId, scriptArgs) {
    const workspaceRoot = resolve(__dirname); // Assumes the script is run from the root
    const srcDir = join(workspaceRoot, SRC_DIR_NAME);

    // Potential paths
    const pathAsIs = join(srcDir, scriptId); // Handles cases where extension is already included by user

    let targetScript = "";

    // Check existence in order of preference - first check for index files in directory
    let pathDirIndex = "";
    for (const indexFile of INDEX_FILE_NAMES) {
        const potentialPath = join(srcDir, scriptId, indexFile);
        if (existsSync(potentialPath)) {
            pathDirIndex = potentialPath;
            break;
        }
    }

    if (pathDirIndex) {
        targetScript = pathDirIndex;
    } else if (existsSync(pathAsIs) && SCRIPT_EXTENSIONS.some((ext) => pathAsIs.endsWith(ext))) {
        // Check if user provided path with valid extension
        targetScript = pathAsIs;
    } else {
        // Try each extension
        for (const ext of SCRIPT_EXTENSIONS) {
            const pathWithExt = join(srcDir, `${scriptId}${ext}`);
            if (existsSync(pathWithExt)) {
                targetScript = pathWithExt;
                break;
            }
        }

        if (!targetScript) {
            const chalk = (await import("chalk")).default;
            // Fuzzy match: find tools that contain the input or share segments
            const availableTools = await getAvailableTools(srcDir);
            const searchTerm = scriptId.toLowerCase().replace(/[-_]+$/, ""); // strip trailing dashes
            const matches = availableTools.filter(t => {
                const lower = t.toLowerCase();
                if (lower.includes(scriptId.toLowerCase())) return true;
                if (searchTerm && lower.includes(searchTerm)) return true;
                // Segment match: any dash-separated part starts with search term
                return lower.split("-").some(seg => seg.startsWith(searchTerm));
            });

            if (matches.length === 0) {
                console.error(
                    `\n  ${chalk.red("Tool not found:")} ${chalk.bold(scriptId)}\n` +
                    `  Looked in: ${chalk.dim(srcDir)}\n`
                );
                process.exit(1);
            }

            // Launch interactive selector pre-filtered with matches
            console.log(`\n  ${chalk.yellow("No exact match for")} ${chalk.bold(scriptId)}${chalk.yellow(". Did you mean?")}\n`);

            try {
                const tool = await search({
                    message: "Select a tool:",
                    source: async (term) => {
                        const filtered = matches.filter(t =>
                            t.toLowerCase().includes((term || "").toLowerCase())
                        );
                        return filtered.map(t => ({ value: t, name: t }));
                    },
                });

                // Re-execute with the selected tool
                await executeTool(tool, scriptArgs);
            } catch (error) {
                if (error instanceof ExitPromptError) {
                    process.exit(0);
                }
                throw error;
            }
            return;
        }
    }

    // Execute bun run using spawnSync
    const result = spawnSync("bun", ["run", targetScript, ...scriptArgs], {
        stdio: "inherit",
        cwd: process.cwd(),
        shell: process.platform === "win32",
    });

    process.exit(result.status ?? 1);
}

// --- Main Logic ---
async function main() {
    const args = process.argv.slice(2);
    const workspaceRoot = resolve(__dirname);
    const srcDir = join(workspaceRoot, SRC_DIR_NAME);

    if (args.length === 0) {
        // Launch interactive tool browser
        const result = spawnSync("bun", ["run", join(srcDir, "tools", "index.ts")], {
            stdio: "inherit",
            cwd: process.cwd(),
        });
        process.exit(result.status ?? 0);
    } else {
        // Arguments provided: Execute the tool
        const scriptId = args[0];
        const scriptArgs = args.slice(1);
        await executeTool(scriptId, scriptArgs);
    }
}

main().catch((err) => {
    logger.error("\n✖ An unexpected error occurred in the main execution:", err);
    process.exit(1);
});
